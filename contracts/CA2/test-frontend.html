<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RecipeNFT ERC-4907 æµ‹è¯•é¡µé¢</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.8.1/ethers.umd.min.js" type="application/javascript"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #f0f0f0;
            border-radius: 15px;
            background: #fafafa;
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-info {
            background: #17a2b8;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .wallet-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .wallet-info h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .token-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .token-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .token-item:last-child {
            border-bottom: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .authorization-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¹ RecipeNFT ERC-4907 æµ‹è¯•é¡µé¢</h1>
            <p>é¸¡å°¾é…’é…æ–¹NFTæ™ºèƒ½åˆçº¦äº¤äº’ç•Œé¢ - æ”¯æŒERC-4907æˆæƒåŠŸèƒ½</p>
        </div>

        <div class="content">
            <!-- é’±åŒ…è¿æ¥åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ”— é’±åŒ…è¿æ¥</h2>
                <div id="walletStatus" class="status info">
                    è¯·è¿æ¥MetaMaské’±åŒ…ä»¥å¼€å§‹æµ‹è¯•
                </div>
                <button id="connectWallet" class="btn">è¿æ¥é’±åŒ…</button>
                <div id="walletInfo" class="wallet-info hidden">
                    <h3>é’±åŒ…ä¿¡æ¯</h3>
                    <p><strong>åœ°å€:</strong> <span id="walletAddress"></span></p>
                    <p><strong>ç½‘ç»œ:</strong> <span id="networkName"></span></p>
                    <p><strong>ä½™é¢:</strong> <span id="walletBalance"></span> ETH</p>
                </div>
            </div>

            <!-- åˆçº¦é…ç½®åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ“‹ åˆçº¦é…ç½®</h2>
                <div class="form-group">
                    <label for="contractAddress">RecipeNFTåˆçº¦åœ°å€:</label>
                    <input type="text" id="contractAddress" placeholder="è¾“å…¥éƒ¨ç½²çš„RecipeNFTåˆçº¦åœ°å€">
                </div>
                <button id="loadContract" class="btn">åŠ è½½åˆçº¦</button>
                <div id="contractStatus" class="status info hidden">
                    è¯·å…ˆè¿æ¥é’±åŒ…å¹¶è¾“å…¥åˆçº¦åœ°å€
                </div>
            </div>

            <!-- NFTé“¸é€ åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸª™ é“¸é€ Recipe NFT</h2>
                <div class="form-group">
                    <label for="tokenURI">IPFSå…ƒæ•°æ®URI:</label>
                    <input type="text" id="tokenURI" placeholder="ä¾‹å¦‚: ipfs://QmYourMetadataHash">
                </div>
                <button id="mintNFT" class="btn btn-success">é“¸é€ NFT</button>
                <div id="mintStatus" class="status hidden"></div>
            </div>

            <!-- ERC-4907 æˆæƒç®¡ç†åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ” ERC-4907 æˆæƒç®¡ç†</h2>
                <div class="authorization-info">
                    <strong>è¯´æ˜:</strong> è¿™é‡Œå¯ä»¥æµ‹è¯•å°†Recipe NFTæˆæƒç»™ID NFTï¼ˆæˆ–å…¶ä»–åœ°å€ï¼‰ï¼Œå®ç°ä¸´æ—¶è®¿é—®æƒé™ç®¡ç†ã€‚
                </div>
                
                <div class="grid-2">
                    <div>
                        <h3>è®¾ç½®æˆæƒç”¨æˆ·</h3>
                        <div class="form-group">
                            <label for="authTokenId">Recipe NFT Token ID:</label>
                            <input type="number" id="authTokenId" placeholder="è¾“å…¥Recipe NFTçš„Token ID">
                        </div>
                        <div class="form-group">
                            <label for="authUserAddress">æˆæƒç”¨æˆ·åœ°å€ (ID NFTåœ°å€):</label>
                            <input type="text" id="authUserAddress" placeholder="è¾“å…¥è¦æˆæƒçš„åœ°å€">
                        </div>
                        <div class="form-group">
                            <label for="authExpires">æˆæƒè¿‡æœŸæ—¶é—´ (ç§’):</label>
                            <input type="number" id="authExpires" placeholder="ä¾‹å¦‚: 3600 (1å°æ—¶)" value="3600">
                        </div>
                        <button id="setUser" class="btn btn-info">è®¾ç½®æˆæƒç”¨æˆ·</button>
                        <button id="removeUser" class="btn btn-danger">ç§»é™¤æˆæƒç”¨æˆ·</button>
                    </div>
                    
                    <div>
                        <h3>æˆæƒçŠ¶æ€æŸ¥è¯¢</h3>
                        <div class="form-group">
                            <label for="queryTokenId">æŸ¥è¯¢Token ID:</label>
                            <input type="number" id="queryTokenId" placeholder="è¾“å…¥è¦æŸ¥è¯¢çš„Token ID">
                        </div>
                        <button id="getUserInfo" class="btn btn-secondary">æŸ¥è¯¢æˆæƒç”¨æˆ·</button>
                        <button id="checkAccess" class="btn btn-secondary">æ£€æŸ¥è®¿é—®æƒé™</button>
                        <div id="authQueryResults" class="status hidden"></div>
                    </div>
                </div>
                
                <div id="authStatus" class="status hidden"></div>
            </div>

            <!-- ä»·æ ¼å’Œé”€å”®çŠ¶æ€ç®¡ç† -->
            <div class="section">
                <h2>ğŸ’° ä»·æ ¼å’Œé”€å”®ç®¡ç†</h2>
                <div class="grid-2">
                    <div>
                        <h3>è®¾ç½®ä»·æ ¼</h3>
                        <div class="form-group">
                            <label for="priceTokenId">Token ID:</label>
                            <input type="number" id="priceTokenId" placeholder="è¾“å…¥Token ID">
                        </div>
                        <div class="form-group">
                            <label for="priceAmount">æˆæƒä»·æ ¼ (USDT, wei):</label>
                            <input type="number" id="priceAmount" placeholder="ä¾‹å¦‚: 1000000000000000000 (1 USDT)">
                        </div>
                        <button id="setPrice" class="btn btn-warning">è®¾ç½®ä»·æ ¼</button>
                    </div>
                    
                    <div>
                        <h3>é”€å”®çŠ¶æ€</h3>
                        <div class="form-group">
                            <label for="saleTokenId">Token ID:</label>
                            <input type="number" id="saleTokenId" placeholder="è¾“å…¥Token ID">
                        </div>
                        <button id="setForSale" class="btn btn-success">è®¾ç½®ä¸ºå¯æˆæƒ</button>
                        <button id="setNotForSale" class="btn btn-danger">è®¾ç½®ä¸ºä¸å¯æˆæƒ</button>
                    </div>
                </div>
                <div id="saleStatus" class="status hidden"></div>
            </div>

            <!-- NFTç®¡ç†åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ”§ NFTç®¡ç†</h2>
                <div class="form-group">
                    <label for="tokenId">Token ID:</label>
                    <input type="number" id="tokenId" placeholder="è¾“å…¥è¦ç®¡ç†çš„NFTçš„Token ID">
                </div>
                <div class="form-group">
                    <label for="newTokenURI">æ–°çš„IPFS URI (ç”¨äºæ›´æ–°):</label>
                    <input type="text" id="newTokenURI" placeholder="è¾“å…¥æ–°çš„IPFSå…ƒæ•°æ®URI">
                </div>
                <button id="updateTokenURI" class="btn btn-warning">æ›´æ–°å…ƒæ•°æ®</button>
                <button id="deactivateNFT" class="btn btn-danger">åœç”¨NFT</button>
                <button id="reactivateNFT" class="btn btn-success">é‡æ–°æ¿€æ´»NFT</button>
                <button id="getMetadata" class="btn btn-secondary">æŸ¥è¯¢å…ƒæ•°æ®</button>
                <div id="managementStatus" class="status hidden"></div>
            </div>

            <!-- æŸ¥è¯¢åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ” æŸ¥è¯¢åŠŸèƒ½</h2>
                <button id="getMyTokens" class="btn btn-secondary">æŸ¥è¯¢æˆ‘çš„NFT</button>
                <button id="getTokenCount" class="btn btn-secondary">æŸ¥è¯¢æ€»æ•°é‡</button>
                <button id="getForSaleTokens" class="btn btn-secondary">æŸ¥è¯¢å¯æˆæƒçš„NFT</button>
                <button id="getAuthorizedTokens" class="btn btn-secondary">æŸ¥è¯¢æˆ‘è¢«æˆæƒçš„NFT</button>
                <div id="queryResults" class="status hidden"></div>
                <div id="tokenList" class="token-list hidden"></div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let provider;
        let signer;
        let contract;
        let walletAddress;
        
        // è·å–åˆçº¦å®ä¾‹çš„è¾…åŠ©å‡½æ•°
        function getContractWithProvider() {
            if (!contract || !provider) return null;
            return new ethers.Contract(contract.address, contractABI, provider);
        }
        
        // è·å–åˆçº¦å®ä¾‹çš„è¾…åŠ©å‡½æ•°ï¼ˆç”¨äºwriteæ“ä½œï¼‰
        function getContractWithSigner() {
            if (!contract || !signer) return null;
            return new ethers.Contract(contract.address, contractABI, signer);
        }

        // RecipeNFTåˆçº¦ABI (åŒ…å«ERC-4907åŠŸèƒ½)
        const contractABI = [
            "function mintRecipeNFT(string uri) external returns (uint256)",
            "function updateTokenURI(uint256 tokenId, string newURI) external",
            "function deactivateRecipeNFT(uint256 tokenId) external",
            "function reactivateRecipeNFT(uint256 tokenId) external",
            "function getRecipeMetadata(uint256 tokenId) external view returns (string uri, bool isActive, uint256 createdAt, uint256 updatedAt, uint256 price, bool isForSale)",
            "function getTokenIdsByOwner(address owner) external view returns (uint256[])",
            "function getAuthorizedTokenIdsByUser(address user) external view returns (uint256[])",
            "function totalSupply() external view returns (uint256)",
            "function ownerOf(uint256 tokenId) external view returns (address)",
            "function tokenURI(uint256 tokenId) external view returns (string)",
            "function userOf(uint256 tokenId) external view returns (address user, uint64 expires)",
            "function setUser(uint256 tokenId, address user, uint64 expires) external",
            "function removeUser(uint256 tokenId) external",
            "function hasAccess(uint256 tokenId, address user) external view returns (bool)",
            "function setPrice(uint256 tokenId, uint256 price) external",
            "function setSaleStatus(uint256 tokenId, bool isForSale) external",
            "function getForSaleTokens() external view returns (uint256[])",
            "event RecipeNFTCreated(uint256 indexed tokenId, address indexed owner, string tokenURI)",
            "event RecipeMetadataUpdated(uint256 indexed tokenId, string newTokenURI)",
            "event RecipeNFTDeactivated(uint256 indexed tokenId)",
            "event RecipeNFTReactivated(uint256 indexed tokenId)",
            "event UserUpdated(uint256 indexed tokenId, address indexed user, uint64 expires)",
            "event PriceSet(uint256 indexed tokenId, uint256 price)",
            "event SaleStatusChanged(uint256 indexed tokenId, bool isForSale)"
        ];

        // ç½‘ç»œé…ç½®
        const networks = {
            1: "Ethereum Mainnet",
            5: "Goerli Testnet",
            11155111: "Sepolia Testnet",
            137: "Polygon Mainnet",
            80001: "Mumbai Testnet"
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            checkWalletConnection();
        });

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('loadContract').addEventListener('click', loadContract);
            document.getElementById('mintNFT').addEventListener('click', mintNFT);
            document.getElementById('updateTokenURI').addEventListener('click', updateTokenURI);
            document.getElementById('deactivateNFT').addEventListener('click', deactivateNFT);
            document.getElementById('reactivateNFT').addEventListener('click', reactivateNFT);
            document.getElementById('getMetadata').addEventListener('click', getMetadata);
            document.getElementById('getMyTokens').addEventListener('click', getMyTokens);
            document.getElementById('getTokenCount').addEventListener('click', getTokenCount);
            document.getElementById('getForSaleTokens').addEventListener('click', getForSaleTokens);
            document.getElementById('getAuthorizedTokens').addEventListener('click', getAuthorizedTokens);
            
            // ERC-4907 æˆæƒåŠŸèƒ½
            document.getElementById('setUser').addEventListener('click', setUser);
            document.getElementById('removeUser').addEventListener('click', removeUser);
            document.getElementById('getUserInfo').addEventListener('click', getUserInfo);
            document.getElementById('checkAccess').addEventListener('click', checkAccess);
            
            // ä»·æ ¼å’Œé”€å”®ç®¡ç†
            document.getElementById('setPrice').addEventListener('click', setPrice);
            document.getElementById('setForSale').addEventListener('click', setForSale);
            document.getElementById('setNotForSale').addEventListener('click', setNotForSale);
        }

        // æ£€æŸ¥é’±åŒ…è¿æ¥çŠ¶æ€
        async function checkWalletConnection() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        await setupWallet(accounts[0]);
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥é’±åŒ…è¿æ¥å¤±è´¥:', error);
                }
            }
        }

        // è¿æ¥é’±åŒ…
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showStatus('walletStatus', 'è¯·å®‰è£…MetaMaské’±åŒ…', 'error');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                await setupWallet(accounts[0]);
                showStatus('walletStatus', 'é’±åŒ…è¿æ¥æˆåŠŸï¼', 'success');
            } catch (error) {
                showStatus('walletStatus', 'é’±åŒ…è¿æ¥å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®é’±åŒ…
        async function setupWallet(address) {
            walletAddress = address;
            provider = new ethers.BrowserProvider(window.ethereum);
            signer = provider.getSigner();
            
            // æ›´æ–°UI
            document.getElementById('walletAddress').textContent = address;
            document.getElementById('walletInfo').classList.remove('hidden');
            
            // è·å–ç½‘ç»œä¿¡æ¯
            const network = await provider.getNetwork();
            document.getElementById('networkName').textContent = networks[network.chainId] || `Chain ID: ${network.chainId}`;
            
            // è·å–ä½™é¢
            const balance = await provider.getBalance(address);
            document.getElementById('walletBalance').textContent = ethers.formatEther(balance);

            // ç›‘å¬è´¦æˆ·å˜åŒ–
            window.ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length > 0) {
                    setupWallet(accounts[0]);
                } else {
                    resetWallet();
                }
            });

            // ç›‘å¬ç½‘ç»œå˜åŒ–
            window.ethereum.on('chainChanged', function (chainId) {
                window.location.reload();
            });
        }

        // é‡ç½®é’±åŒ…
        function resetWallet() {
            walletAddress = null;
            provider = null;
            signer = null;
            contract = null;
            document.getElementById('walletInfo').classList.add('hidden');
            showStatus('walletStatus', 'é’±åŒ…å·²æ–­å¼€è¿æ¥', 'info');
        }

        // åŠ è½½åˆçº¦
        async function loadContract() {
            const contractAddress = document.getElementById('contractAddress').value.trim();
            
            if (!contractAddress) {
                showStatus('contractStatus', 'è¯·è¾“å…¥åˆçº¦åœ°å€', 'error');
                return;
            }

            if (!ethers.isAddress(contractAddress)) {
                showStatus('contractStatus', 'æ— æ•ˆçš„åˆçº¦åœ°å€', 'error');
                return;
            }

            if (!signer) {
                showStatus('contractStatus', 'è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            try {
                // ä½¿ç”¨provideråˆ›å»ºåˆçº¦å®ä¾‹ç”¨äºviewå‡½æ•°
                const provider = await signer.provider;
                contract = new ethers.Contract(contractAddress, contractABI, provider);
                
                // æµ‹è¯•åˆçº¦è¿æ¥
                await contract.totalSupply();
                
                showStatus('contractStatus', 'åˆçº¦åŠ è½½æˆåŠŸï¼', 'success');
                document.getElementById('contractStatus').classList.remove('hidden');
            } catch (error) {
                showStatus('contractStatus', 'åˆçº¦åŠ è½½å¤±è´¥: ' + error.message, 'error');
            }
        }

        // é“¸é€ NFT
        async function mintNFT() {
            if (!contract) {
                showStatus('mintStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenURI = document.getElementById('tokenURI').value.trim();
            if (!tokenURI) {
                showStatus('mintStatus', 'è¯·è¾“å…¥IPFS URI', 'error');
                return;
            }

            try {
                showStatus('mintStatus', 'æ­£åœ¨é“¸é€ NFT...', 'info');
                const button = document.getElementById('mintNFT');
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> é“¸é€ ä¸­...';

                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('mintStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.mintRecipeNFT(tokenURI);
                await tx.wait();

                showStatus('mintStatus', 'NFTé“¸é€ æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
                button.disabled = false;
                button.textContent = 'é“¸é€ NFT';
            } catch (error) {
                showStatus('mintStatus', 'é“¸é€ å¤±è´¥: ' + error.message, 'error');
                document.getElementById('mintNFT').disabled = false;
                document.getElementById('mintNFT').textContent = 'é“¸é€ NFT';
            }
        }

        // ERC-4907 è®¾ç½®æˆæƒç”¨æˆ·
        async function setUser() {
            if (!contract) {
                showStatus('authStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('authTokenId').value;
            const userAddress = document.getElementById('authUserAddress').value.trim();
            const expires = document.getElementById('authExpires').value;

            if (!tokenId || !userAddress || !expires) {
                showStatus('authStatus', 'è¯·å¡«å†™æ‰€æœ‰å­—æ®µ', 'error');
                return;
            }

            if (!ethers.isAddress(userAddress)) {
                showStatus('authStatus', 'æ— æ•ˆçš„ç”¨æˆ·åœ°å€', 'error');
                return;
            }

            try {
                showStatus('authStatus', 'æ­£åœ¨è®¾ç½®æˆæƒç”¨æˆ·...', 'info');
                const expiresTime = Math.floor(Date.now() / 1000) + parseInt(expires);
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('authStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.setUser(tokenId, userAddress, expiresTime);
                await tx.wait();
                showStatus('authStatus', 'æˆæƒç”¨æˆ·è®¾ç½®æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
            } catch (error) {
                showStatus('authStatus', 'è®¾ç½®å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ERC-4907 ç§»é™¤æˆæƒç”¨æˆ·
        async function removeUser() {
            if (!contract) {
                showStatus('authStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('authTokenId').value;
            if (!tokenId) {
                showStatus('authStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                showStatus('authStatus', 'æ­£åœ¨ç§»é™¤æˆæƒç”¨æˆ·...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('authStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.removeUser(tokenId);
                await tx.wait();
                showStatus('authStatus', 'æˆæƒç”¨æˆ·ç§»é™¤æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
            } catch (error) {
                showStatus('authStatus', 'ç§»é™¤å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æŸ¥è¯¢æˆæƒç”¨æˆ·ä¿¡æ¯
        async function getUserInfo() {
            if (!contract) {
                showStatus('authQueryResults', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('queryTokenId').value;
            if (!tokenId) {
                showStatus('authQueryResults', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('authQueryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const [user, expires] = await contractWithProvider.userOf(tokenId);
                if (user === ethers.ZeroAddress) {
                    showStatus('authQueryResults', 'è¯¥NFTæ²¡æœ‰æˆæƒç”¨æˆ·', 'info');
                } else {
                    const expiresDate = new Date(expires * 1000);
                    const isExpired = expires < Math.floor(Date.now() / 1000);
                    const result = `
                        <strong>æˆæƒç”¨æˆ·:</strong> ${user}<br>
                        <strong>è¿‡æœŸæ—¶é—´:</strong> ${expiresDate.toLocaleString()}<br>
                        <strong>çŠ¶æ€:</strong> ${isExpired ? 'å·²è¿‡æœŸ' : 'æœ‰æ•ˆ'}
                    `;
                    showStatus('authQueryResults', result, isExpired ? 'error' : 'success');
                }
            } catch (error) {
                showStatus('authQueryResults', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ£€æŸ¥è®¿é—®æƒé™
        async function checkAccess() {
            if (!contract) {
                showStatus('authQueryResults', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('queryTokenId').value;
            if (!tokenId) {
                showStatus('authQueryResults', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            if (!walletAddress) {
                showStatus('authQueryResults', 'è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('authQueryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const hasAccess = await contractWithProvider.hasAccess(tokenId, walletAddress);
                const result = `å½“å‰é’±åŒ…åœ°å€ ${walletAddress} ${hasAccess ? 'æœ‰' : 'æ²¡æœ‰'}è®¿é—®æƒé™`;
                showStatus('authQueryResults', result, hasAccess ? 'success' : 'error');
            } catch (error) {
                showStatus('authQueryResults', 'æ£€æŸ¥å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®ä»·æ ¼
        async function setPrice() {
            if (!contract) {
                showStatus('saleStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('priceTokenId').value;
            const price = document.getElementById('priceAmount').value;

            if (!tokenId || !price) {
                showStatus('saleStatus', 'è¯·å¡«å†™æ‰€æœ‰å­—æ®µ', 'error');
                return;
            }

            try {
                showStatus('saleStatus', 'æ­£åœ¨è®¾ç½®ä»·æ ¼...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('saleStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.setPrice(tokenId, price);
                await tx.wait();
                showStatus('saleStatus', 'ä»·æ ¼è®¾ç½®æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
            } catch (error) {
                showStatus('saleStatus', 'è®¾ç½®å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®ä¸ºå¯æˆæƒ
        async function setForSale() {
            if (!contract) {
                showStatus('saleStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('saleTokenId').value;
            if (!tokenId) {
                showStatus('saleStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                showStatus('saleStatus', 'æ­£åœ¨è®¾ç½®ä¸ºå¯æˆæƒ...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('saleStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.setSaleStatus(tokenId, true);
                await tx.wait();
                showStatus('saleStatus', 'è®¾ç½®ä¸ºå¯æˆæƒæˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
            } catch (error) {
                showStatus('saleStatus', 'è®¾ç½®å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®ä¸ºä¸å¯æˆæƒ
        async function setNotForSale() {
            if (!contract) {
                showStatus('saleStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('saleTokenId').value;
            if (!tokenId) {
                showStatus('saleStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                showStatus('saleStatus', 'æ­£åœ¨è®¾ç½®ä¸ºä¸å¯æˆæƒ...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('saleStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.setSaleStatus(tokenId, false);
                await tx.wait();
                showStatus('saleStatus', 'è®¾ç½®ä¸ºä¸å¯æˆæƒæˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ' + tx.hash, 'success');
            } catch (error) {
                showStatus('saleStatus', 'è®¾ç½®å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ›´æ–°Token URI
        async function updateTokenURI() {
            if (!contract) {
                showStatus('managementStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('tokenId').value;
            const newTokenURI = document.getElementById('newTokenURI').value.trim();

            if (!tokenId || !newTokenURI) {
                showStatus('managementStatus', 'è¯·è¾“å…¥Token IDå’Œæ–°çš„URI', 'error');
                return;
            }

            try {
                showStatus('managementStatus', 'æ­£åœ¨æ›´æ–°å…ƒæ•°æ®...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('managementStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.updateTokenURI(tokenId, newTokenURI);
                await tx.wait();
                showStatus('managementStatus', 'å…ƒæ•°æ®æ›´æ–°æˆåŠŸï¼', 'success');
            } catch (error) {
                showStatus('managementStatus', 'æ›´æ–°å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åœç”¨NFT
        async function deactivateNFT() {
            if (!contract) {
                showStatus('managementStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('tokenId').value;
            if (!tokenId) {
                showStatus('managementStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                showStatus('managementStatus', 'æ­£åœ¨åœç”¨NFT...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('managementStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.deactivateRecipeNFT(tokenId);
                await tx.wait();
                showStatus('managementStatus', 'NFTå·²åœç”¨ï¼', 'success');
            } catch (error) {
                showStatus('managementStatus', 'åœç”¨å¤±è´¥: ' + error.message, 'error');
            }
        }

        // é‡æ–°æ¿€æ´»NFT
        async function reactivateNFT() {
            if (!contract) {
                showStatus('managementStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('tokenId').value;
            if (!tokenId) {
                showStatus('managementStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                showStatus('managementStatus', 'æ­£åœ¨é‡æ–°æ¿€æ´»NFT...', 'info');
                const contractWithSigner = getContractWithSigner();
                if (!contractWithSigner) {
                    showStatus('managementStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tx = await contractWithSigner.reactivateRecipeNFT(tokenId);
                await tx.wait();
                showStatus('managementStatus', 'NFTå·²é‡æ–°æ¿€æ´»ï¼', 'success');
            } catch (error) {
                showStatus('managementStatus', 'æ¿€æ´»å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–å…ƒæ•°æ®
        async function getMetadata() {
            if (!contract) {
                showStatus('managementStatus', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            const tokenId = document.getElementById('tokenId').value;
            if (!tokenId) {
                showStatus('managementStatus', 'è¯·è¾“å…¥Token ID', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('managementStatus', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const metadata = await contractWithProvider.getRecipeMetadata(tokenId);
                const result = `
                    <strong>Token ID:</strong> ${tokenId}<br>
                    <strong>URI:</strong> ${metadata.uri}<br>
                    <strong>æ¿€æ´»çŠ¶æ€:</strong> ${metadata.isActive ? 'æ¿€æ´»' : 'åœç”¨'}<br>
                    <strong>åˆ›å»ºæ—¶é—´:</strong> ${new Date(metadata.createdAt * 1000).toLocaleString()}<br>
                    <strong>æ›´æ–°æ—¶é—´:</strong> ${new Date(metadata.updatedAt * 1000).toLocaleString()}<br>
                    <strong>ä»·æ ¼:</strong> ${ethers.formatEther(metadata.price)} USDT<br>
                    <strong>å¯æˆæƒ:</strong> ${metadata.isForSale ? 'æ˜¯' : 'å¦'}
                `;
                showStatus('managementStatus', result, 'info');
            } catch (error) {
                showStatus('managementStatus', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–æˆ‘çš„NFT
        async function getMyTokens() {
            if (!contract || !walletAddress) {
                showStatus('queryResults', 'è¯·å…ˆè¿æ¥é’±åŒ…å¹¶åŠ è½½åˆçº¦', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('queryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const tokenIds = await contractWithProvider.getTokenIdsByOwner(walletAddress);
                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '';

                if (tokenIds.length === 0) {
                    showStatus('queryResults', 'æ‚¨è¿˜æ²¡æœ‰ä»»ä½•NFT', 'info');
                    return;
                }

                showStatus('queryResults', `æ‰¾åˆ° ${tokenIds.length} ä¸ªNFT:`, 'success');
                tokenList.classList.remove('hidden');

                for (let i = 0; i < tokenIds.length; i++) {
                    const tokenId = tokenIds[i];
                    const tokenItem = document.createElement('div');
                    tokenItem.className = 'token-item';
                    tokenItem.innerHTML = `
                        <span>Token ID: ${tokenId.toString()}</span>
                        <button onclick="getTokenDetails(${tokenId})" class="btn btn-secondary">æŸ¥çœ‹è¯¦æƒ…</button>
                    `;
                    tokenList.appendChild(tokenItem);
                }
            } catch (error) {
                showStatus('queryResults', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–Tokenè¯¦æƒ…
        async function getTokenDetails(tokenId) {
            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('queryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const metadata = await contractWithProvider.getRecipeMetadata(tokenId);
                const owner = await contractWithProvider.ownerOf(tokenId);
                const [user, expires] = await contractWithProvider.userOf(tokenId);
                const result = `
                    <strong>Token ID:</strong> ${tokenId}<br>
                    <strong>æ‹¥æœ‰è€…:</strong> ${owner}<br>
                    <strong>URI:</strong> ${metadata.uri}<br>
                    <strong>æ¿€æ´»çŠ¶æ€:</strong> ${metadata.isActive ? 'æ¿€æ´»' : 'åœç”¨'}<br>
                    <strong>åˆ›å»ºæ—¶é—´:</strong> ${new Date(metadata.createdAt * 1000).toLocaleString()}<br>
                    <strong>æ›´æ–°æ—¶é—´:</strong> ${new Date(metadata.updatedAt * 1000).toLocaleString()}<br>
                    <strong>ä»·æ ¼:</strong> ${ethers.formatEther(metadata.price)} USDT<br>
                    <strong>å¯æˆæƒ:</strong> ${metadata.isForSale ? 'æ˜¯' : 'å¦'}<br>
                    <strong>æˆæƒç”¨æˆ·:</strong> ${user === ethers.ZeroAddress ? 'æ— ' : user}<br>
                    <strong>æˆæƒè¿‡æœŸ:</strong> ${user === ethers.ZeroAddress ? 'æ— ' : new Date(expires * 1000).toLocaleString()}
                `;
                showStatus('queryResults', result, 'info');
            } catch (error) {
                showStatus('queryResults', 'è·å–è¯¦æƒ…å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–æ€»æ•°é‡
        async function getTokenCount() {
            if (!contract) {
                showStatus('queryResults', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('queryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const totalSupply = await contractWithProvider.totalSupply();
                showStatus('queryResults', `åˆçº¦ä¸­æ€»å…±æœ‰ ${totalSupply.toString()} ä¸ªNFT`, 'success');
            } catch (error) {
                showStatus('queryResults', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–å¯æˆæƒçš„NFT
        async function getForSaleTokens() {
            if (!contract) {
                showStatus('queryResults', 'è¯·å…ˆåŠ è½½åˆçº¦', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('queryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const forSaleTokens = await contractWithProvider.getForSaleTokens();
                if (forSaleTokens.length === 0) {
                    showStatus('queryResults', 'å½“å‰æ²¡æœ‰å¯æˆæƒçš„NFT', 'info');
                    return;
                }

                showStatus('queryResults', `æ‰¾åˆ° ${forSaleTokens.length} ä¸ªå¯æˆæƒçš„NFT:`, 'success');
                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '';
                tokenList.classList.remove('hidden');

                for (let i = 0; i < forSaleTokens.length; i++) {
                    const tokenId = forSaleTokens[i];
                    const tokenItem = document.createElement('div');
                    tokenItem.className = 'token-item';
                    tokenItem.innerHTML = `
                        <span>Token ID: ${tokenId.toString()}</span>
                        <button onclick="getTokenDetails(${tokenId})" class="btn btn-secondary">æŸ¥çœ‹è¯¦æƒ…</button>
                    `;
                    tokenList.appendChild(tokenItem);
                }
            } catch (error) {
                showStatus('queryResults', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–æˆ‘è¢«æˆæƒçš„NFT
        async function getAuthorizedTokens() {
            if (!contract || !walletAddress) {
                showStatus('queryResults', 'è¯·å…ˆè¿æ¥é’±åŒ…å¹¶åŠ è½½åˆçº¦', 'error');
                return;
            }

            try {
                const contractWithProvider = getContractWithProvider();
                if (!contractWithProvider) {
                    showStatus('queryResults', 'åˆçº¦æœªæ­£ç¡®åŠ è½½', 'error');
                    return;
                }
                const authorizedTokens = await contractWithProvider.getAuthorizedTokenIdsByUser(walletAddress);
                if (authorizedTokens.length === 0) {
                    showStatus('queryResults', 'æ‚¨æ²¡æœ‰è¢«æˆæƒçš„NFT', 'info');
                    return;
                }

                showStatus('queryResults', `æ‚¨è¢«æˆæƒäº† ${authorizedTokens.length} ä¸ªNFT:`, 'success');
                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '';
                tokenList.classList.remove('hidden');

                for (let i = 0; i < authorizedTokens.length; i++) {
                    const tokenId = authorizedTokens[i];
                    const tokenItem = document.createElement('div');
                    tokenItem.className = 'token-item';
                    tokenItem.innerHTML = `
                        <span>Token ID: ${tokenId.toString()}</span>
                        <button onclick="getTokenDetails(${tokenId})" class="btn btn-secondary">æŸ¥çœ‹è¯¦æƒ…</button>
                    `;
                    tokenList.appendChild(tokenItem);
                }
            } catch (error) {
                showStatus('queryResults', 'æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = `status ${type}`;
            element.classList.remove('hidden');
        }
    </script>
</body>
</html> 